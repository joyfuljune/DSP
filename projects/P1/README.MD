# <div align='center'>音频压缩 </div>

#### 目录
 - [引言](#intro)
 - [语音压缩流程](#flow)
 - [DCT压缩技术](#dct)
 	- [DCT原理](#principle)
 	- [变换系数阈值化](#thres)
 		- [DCT示例](#dctex)
 	- [量化](#quan)
 		- [比特量化](#bit)
 	- [编码](#code)
 - [MP3压缩原理](#mp3)
 - [练习](#ex)
 


<a name="intro"></a>
## 引言
言语是人类传递信息的基本方式。言语的主要目的是交际。语音可以定义为声道对一个或多个激励信号的响应。巨量的数据传输无论从传输还是存储上都是非常困难的。语音压缩是一种将人的语音转换成编码形式的方法，这种编码方式可以在以后被解码以获得原始信号。压缩基本上是去除相邻样本之间和相邻周期之间的冗余。语音压缩的目的是用较少的比特数表示信号，以可以接受的质量损失的方式减少数据。

压缩的类型主要有两种压缩技术——无损压缩和有损压缩。无损压缩是一类数据压缩算法，它允许从原始数据重构出精确的原始数据，从压缩后的数据重构出精确的原始数据。它主要用于重要原始信号与解压缩信号几乎相同或完全相同的情况。比如霍夫曼（Huffmann）编码就是一种无损压缩算法。有损压缩是一种通过删除部分数据来压缩数据的数据编码方法。这种技术的目的是最小化必须传输的数据量。

本次实验的主要内容如下：第1节介绍了语音压缩方案的理论背景。第2节介绍了语音压缩技术，第3节对现有的压缩技术进行了评价，并给出了结论。

<a name="flow"></a>
## 语音压缩流程

语音压缩可以分为三种编码形式：

 - **波形编码**：输入信号经过压缩系统后，在系统输出处的重现应与原始信号波形相似。
 - **参数编码**：在这类编码中，信号以小参数的形式表示，这些小参数可以准确地描述信号。在参数提取方法中，用一个预处理器提取一些特征，这些特征可以用来重建原始信号。
 - **转换编码**：这是我们在本次实验中需要使用的编码技术。该方法首先将信号从时域变换到频域，然后对频域进行处理以求只保持信号的主要特征。在变换方法上，可以采用离散小波变换技术和离散余弦变换（DCT）技术。当我们使用小波变换技术时，信号可以用小波展开来表示。类似地，在DCT变换的情况下，可以用DCT系数表示语音。实验部分只需考虑DCT。<br>变换技术不压缩信号，它们提供关于信号的信息，我们可使用各种编码技术对变换后的信号进行压缩，例如通过忽略接近零的或者不太重要的系数和数据，然后对信号进行反变换重构时域信号完成压缩。

DCT压缩编码的主要流程如下图所示
![image](https://user-images.githubusercontent.com/88413945/185788646-7dd9fe77-81db-4ef7-93c9-8b9b7ca4fdc9.png)
<div align='center'><b> 图1. DCT压缩框图 </b></div>

<a name="dct"></a>
## DCT压缩技术

<a name="principle"></a>
### DCT原理
  
对语音信号采用DCT方法可以进行时频变换，DCT的全称是discrete cosine transform,中文是离散余弦变换，这种方法可以非常准确地进行信号重建；DCT的这一特性用于数据压缩是因为其在相邻系数之间具有高相关性，也就是说，我们可以用少部分DCT系数重构原始信号。用少部分代替整体就可以有效降低数据存储量。DCT有4种常见的标准形式，其中一种形式为：
  
$$X[m]=c(m) \sum_{n=0}^{N-1}x[n]cos\left( \frac {(n+1/2) \pi} {N}m\right),m=0,1, \ldots, N-1$$
  
其所对应的逆离散余弦变换，即IDCT公式为：
 
$$x[n]=c(m) \sum_{m=0}^{N-1}X[m]cos\left( \frac {(n+1/2) \pi} {N}m\right),n=0,1, \ldots, N-1$$

其中,   

$$
c_m = \begin{Bmatrix}
\sqrt{\frac{1}{N}} & m=0\\
\sqrt{\frac{2}{N}} & m\ne0
\end{Bmatrix}
$$

N是一维数据的元素总数，c(m)系数使得DCT变换矩阵成为正交矩阵。

<a name="thres"></a>
### 变换系数阈值化
在DCT变化后，得到的频域结果被称作是变换系数，由于DCT具有能量聚集性，所以只需要很少的变换系数，就可以代表总信号中的99%的能量，我们可以设定阈值，删除小于阈值的变换系数。
 
<a name="dctex"></a>
#### DCT示例
我们可以通过<code>doc dct</code>在MATLAB中查看这样的示例。
```matlab
x = (1:100) + 50*cos((1:100)*2*pi/40); % 定义实偶对称离散序列x[n],记作x
X = dct(x);	% 求得X[m]，写作X
[XX,ind] = sort(abs(X),'descend');	% 将X以绝对值降序方式排列
XX =	500.000000000000
	-286.567797994563
	-8.41655611750505
	…
	-0.00333833690211531
	0.00137709244241012
	-0.00111094915171966
plot(x)
plot(XX)
```
![image](https://user-images.githubusercontent.com/88413945/185789329-c8d1eb7e-f8d5-4d06-82be-882f47df35b5.png)
![image](https://user-images.githubusercontent.com/88413945/185789331-3d59e57f-55a7-4396-ab31-07829b02c760.png)

从表中及图中可以发现，尽管XX具有100个数据点，但是t=10之后的数据值相对来说较小，也可以说能量较少，则其能传达的有效信息较少。我们可以猜想下如果删除这一部分信息，对原始信号的影响应该是较小的。但同时由于删除了部分信息，数据长度减小，则重建信号相对原始信号所占用的空间应相应减小。10所对应的y值为3.52，我们以3.52为界，删除X[m]中所有小于该值的数据。

```matlab
X(abs(X)<3.52)=0;	% 阈值为3.52，阈值下数据值为0
new_x = idct(X); % 用idct从频域重建原信号
plot(x);hold on; 
plot(new_x)
```
![image](https://user-images.githubusercontent.com/88413945/185789341-7d2e10d7-ad5f-4d90-ad52-1476db81d725.png)

可以看到重建后的信号和原始信号基本完全重合。但是这种人为选定的方式过于随机，我们还是以例题中的方法进行说明。

```matlab
i = 1;
while norm(X(ind(1:i)))/norm(X) < 0.99
   i = i + 1;
end
needed = i;
```
norm(X)是MATLAB中对于L2范数的求解，范数可以理解为用一个数来代表向量X，norm(X(ind(1:i)))是计算括号中的L2范数，X(ind(1:i))这个向量会随着i的变化产生变化，ind在这里表示绝对值从大到小排序。通过while循环，设定循环条件为X(ind(1:i))向量的范数为X范数的0.99，换句话说，以i为界定，X中1到i的值能否代表99%原始X的信息，如果不可以，则递增i的值，否则停止循环。通过运行发现needed的值应为3。所以X中的前3个最大值（绝对值最大），代表了总能量的99%。

```matlab
X(ind(needed+1:end)) = 0;
xx = idct(X);
plot([x;xx]')
legend('Original',['Reconstructed, N = ' int2str(needed)], ...
       'Location','SouthEast')
```

![image](https://user-images.githubusercontent.com/88413945/185789366-294d4e65-85b3-4659-99a3-5bfde3fdf847.png)

<a name="quan"></a>
### 量化
它是将一组连续值数据映射到一组离散值数据的过程。量化的目的是减少阈值化后所保留的系数中的信息。

<a name="bit"></a>
#### 比特量化
我们首先定义一个区间，例如（-1，1），从连续角度说，-1到1之间有无数个值，例0.99，-0.4521等，量化的概念就是将无限变成可数。令-1到1之间的所有数以4个比特进行表示。这里比特所代表的数字是2进制形式，所以一共有16种情况，即-1到1之间的所有数值被划分为16个值。下图中对灰色连续时间信号作了量化得到红色结果。
![image](https://user-images.githubusercontent.com/88413945/185789389-45dd32b4-54cd-476c-a1c5-0e53cbda648c.png)

实际上，一般我们说将信号进行b比特的量化，需要将首位作为符号位，所以进行量化的位数为b-1。我们有如下公式，对(-L,L)区间信号值进行b比特量化：
量化:  $z = round\left(\frac{y}{q}\right), q = \frac{2L}{2^b-1}$ 
解量化:   $\tilde y=qz$ 

举例：对 $（-1，1）$ 区间的数值以4比特量化， $L=1，b=4，q=\frac{2}{2^4-1}=\frac{2}{15}$ 

 - 假设有数据 $y = -0.3$ , 则 $z=round\left(\frac{-0.3}/{2/15}\right)=round(-2.25)=-2→-010$ 
    - -010即量化后数值，对量化后数值作解量化有 $y ̂=\frac{2}{15}*-2≈0.2667$ 

- 假设有数据 $y = 0.9$ , 则 $z=round\left(\frac{0.9}{2/15}\right)=round(6.75)=7→+111$ 
  - +111即量化后数值，对量化后数值作解量化有 $y ̂=\frac{2}{15}*7≈0.9333$ 

由于保留首位为符号位，实际用3比特进行量化，-1到1区间最终计算得到8种可能。

<a name="code"></a>
### 编码

编码技术是为了删除重复出现的数据。在编码中，我们还可以减少变换系数的数量，去除冗余数据。编码可以使用两种压缩技术中的任何一种，无损或有损。在降低信号带宽的同时，可以实现压缩。压缩后的语音信号通过解码、去量化、逆变换等方法重构成原始信号。这一部分不属于本次实验内容。

<a name="mp3"></a>
### MP3压缩原理
MP3的压缩原理比本次实验内容更为复杂，其压缩思想是，除了设定阈值进行冗余数据删除、量化编码外，还和人体的声学模型进行结合。一个想法是：与其利用阈值切除“不太重要”的频率，我们可以以较低的精度存储相应的模型系数 -也就是说，使用更少的比特量化“不太重要”的频率。图示在量化频带的选择上，变换系数位于浅蓝色区域将以低精度存储。低精度和高精度存储之间的相互配合可以获得更好的整体压缩。例如，假设 90% 的系数位于图中低精度部分。假设我们只用 8 位数字存储这些系数，浅绿色区域用 16 位数字存储。结果数据相比完全使用 16 位数字存储所使用的存储空间节省 55% 左右。

![image](https://user-images.githubusercontent.com/88413945/185789816-aa41bc3c-c188-41e1-870f-ecb596283115.png)

假设每秒 22,050 个样本，我们可以通过扩大低精度区域或降低用于存储系数的精度或两者兼而有之来实现更高的压缩。 mp3 压缩中使用的算法使用类似的技术来实现高达 10:1 的 CD 音频压缩，并且仍然保持高感知质量的声音。

<a name="ex"></a>
## 练习

本次实验是对上述内容的综合体现。需要完成以下内容
1.	读取音频文件并进行分段
2.	对每段音频作DCT能量计算
3.	取阈值为0.99作切割；
4.	对切割后音频作量化和解量化
5.	IDCT变换
6.	合并分段音频
7.	对比原始音频和第6步的输出，计算均方差。

每个步骤都提供了模板函数，只需要补充部分代码。补充完成后可以用测试代码检查结果。最终可通过运行<code>ex0_all.m</code>文件进行合体运行。

所有标记？的部分都需要补充代码，如果？后面有分号<code>；</code>，请保留分号。
在命令行窗口中运行<code>test_cases</code>根据提示输入数字可以检测ex填写正确性。




