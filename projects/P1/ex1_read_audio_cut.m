function [x, x_cut, fs] = ex1_read_audio_cut(window)
%EX1_READ_AUDIO_CUT 读取音频并进行分段
% path作为全局变量在ex0中声明
% 输入参数window是窗户大小，也就是说对音频信号每window长度进行切割
% 由于音频信号一般信号值较多，为了加速计算以及为了更好的重建，我们需要对音频信号
% 进行切割，将一个长为N点的信号切割为N/window点的信号，如果产生小数部分会被舍去
% 也就是说切割后的信号长度小于等于N点。
% 输出参数x和fs是读取音频的音频值和采样频率，一般音频为双声道，这里x经过预处理为一维向量
% 输出参数x_cut是分段后的信号值，是一个二维矩阵。
% =============================信号总长度为N=============================
%  ... x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x ...
% ==========================以window为长度分段==========================
% 1 1 1 1
%         2 2 2 2
%                 3 3 3 3
%                         4 4 4 4 ......................
%                                                          nb nb nb nb
% =============================叠加为列向量=============================
% 1 2 3 4 ... nb   \
% 1 2 3 4 ... nb   |
% 1 2 3 4 ... nb   |    共window行
% 1 2 3 4 ... nb   |
% 1 2 3 4 ... nb   /
% \—————————————/
%     共nb列

global path                     % 全局path为音频读取路径
[x, fs] = audioread(path);      % audioread函数读取音频，保存在x中
% N为x音频的总长度，使用length函数
N = ？;
% nb为音频总共可以切割的段数，使用floor函数舍弃小数位
nb = ？;
% 设定x_cut大小为window*nb，横行表示window长度，纵列表示共有nb分段
% 用zeros函数初始化x_cut
x_cut = ？;
% 循环，将第1到nb个分段的值保存在列向量中
for n = 1:nb
    x_cut(:, n) = ？;
end
